#this part belongs to conftest.py

from contextlib import contextmanager
from datetime import datetime
from typing import AsyncIterator, Generator

# import factory
import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from sqlalchemy import event
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.pool import StaticPool

from fastapi_lesson.app import app
from fastapi_lesson.database import get_session
from fastapi_lesson.models import User, table_registry
from fastapi_lesson.schemas import UserFactory
from fastapi_lesson.security import get_password_hash
from fastapi_lesson.settings import Settings


@pytest.fixture
def client(session) -> Generator[TestClient, None, None]:
    def get_session_override():
        return session

    with TestClient(app) as client:
        app.dependency_overrides[get_session] = get_session_override

        yield client

    app.dependency_overrides.clear()


@pytest_asyncio.fixture
async def session() -> AsyncIterator[AsyncSession]:
    engine = create_async_engine(
        "sqlite+aiosqlite:///:memory:",
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )

    async with engine.begin() as conn:
        await conn.run_sync(table_registry.metadata.create_all)

    async with AsyncSession(engine, expire_on_commit=False) as session:
        yield session

    async with engine.begin() as conn:
        await conn.run_sync(table_registry.metadata.drop_all)


@contextmanager
def _mock_db_time(*, model, time=datetime(2025, 5, 29)) -> Generator[None, None, None]:
    def fake_time_hook(mapper, connection, target) -> None:
        if hasattr(target, "created_at"):
            target.created_at = time

    event.listen(model, "before_insert", fake_time_hook)

    yield time

    event.remove(model, "before_insert", fake_time_hook)


@pytest.fixture
def mock_db_time() -> Generator[None, None, None]:
    return _mock_db_time


@pytest_asyncio.fixture
async def user(session: AsyncSession) -> User:
    password = "testtest"
    user = UserFactory(password=get_password_hash(password))

    session.add(user)
    await session.commit()
    await session.refresh(user)
    user.clean_password = password

    return user


@pytest_asyncio.fixture
async def other_user(session: AsyncSession) -> User:
    password = "testtest"
    user = UserFactory(password=get_password_hash(password))

    session.add(user)
    await session.commit()
    await session.refresh(user)
    user.clean_password = password

    return user


@pytest.fixture
def token(client, user) -> str:
    response = client.post(
        "/auth/token", data={"username": user.email, "password": user.clean_password}
    )
    return response.json()["access_token"]


@pytest.fixture
def settings() -> Settings:
    return Settings()


# class UserFactory(factory.Factory):
#     class Meta:
#         model = User

#     username = factory.Sequence(lambda n: f"test{n}")
#     email = factory.LazyAttribute(lambda obj: f"{obj.username}@etest.com")
#     password = factory.LazyAttribute(lambda obj: f"{obj.username}secret")


########################################+++++++++++++########################################
#"""This another part belongs to test_todo.py"""

from http import HTTPStatus

import pytest

from fastapi_lesson.schemas import TodoFactory, TodoState

# class TodoFactory(factory.Factory):
#     class Meta:
#         model = Todo

#     title = factory.Faker("text")
#     description = factory.Faker("text")
#     state = factory.fuzzy.FuzzyChoice(TodoState)
#     user_id = 1


def test_create_todo(client, token) -> None:
    response = client.post(
        "/todos/",
        headers={"Authorization": f"Bearer {token}"},
        json={
            "title": "Test todo",
            "description": "Test todo description",
            "state": "draft",
        },
    )
    assert response.json() == {
        "id": 1,
        "title": "Test todo",
        "description": "Test todo description",
        "state": "draft",
    }


@pytest.mark.asyncio
async def test_list_todos_should_return_5_todos(session, client, user, token) -> None:
    expected_todos = 5
    session.add_all(TodoFactory.create_batch(5, user_id=user.id))
    await session.commit()

    response = client.get(
        "/todos/",
        headers={"Authorization": f"Bearer {token}"},
    )

    assert len(response.json()["todos"]) == expected_todos


@pytest.mark.asyncio
async def test_list_todos_pagination_should_return_2_todos(
    session, user, client, token
) -> None:
    expected_todos = 2
    session.add_all(TodoFactory.create_batch(5, user_id=user.id))
    await session.commit()

    response = client.get(
        "/todos/?offset=1&limit=2",
        headers={"Authorization": f"Bearer {token}"},
    )

    assert len(response.json()["todos"]) == expected_todos


@pytest.mark.asyncio
async def test_list_todos_filter_title_should_return_5_todos(
    session, user, client, token
) -> None:
    expected_todos = 5
    session.add_all(TodoFactory.create_batch(5, user_id=user.id, title="Test todo 1"))
    await session.commit()

    response = client.get(
        "/todos/?title=Test todo 1",
        headers={"Authorization": f"Bearer {token}"},
    )

    assert len(response.json()["todos"]) == expected_todos


@pytest.mark.asyncio
async def test_list_todos_filter_description_should_return_5_todos(
    session, user, client, token
) -> None:
    expected_todos = 5
    session.add_all(
        TodoFactory.create_batch(5, user_id=user.id, description="description")
    )
    await session.commit()

    response = client.get(
        "/todos/?description=desc",
        headers={"Authorization": f"Bearer {token}"},
    )

    assert len(response.json()["todos"]) == expected_todos


@pytest.mark.asyncio
async def test_list_todos_filter_state_should_return_5_todos(
    session, user, client, token
) -> None:
    expected_todos = 5
    session.add_all(TodoFactory.create_batch(5, user_id=user.id, state=TodoState.draft))
    await session.commit()

    response = client.get(
        "/todos/?state=draft",
        headers={"Authorization": f"Bearer {token}"},
    )

    assert len(response.json()["todos"]) == expected_todos


@pytest.mark.asyncio
async def test_list_todos_filter_combined_should_return_5_todos(
    session, user, client, token
) -> None:
    expected_todos = 5
    session.add_all(
        TodoFactory.create_batch(
            5,
            user_id=user.id,
            title="Test todo combined",
            description="combined description",
            state=TodoState.done,
        )
    )

    session.add_all(
        TodoFactory.create_batch(
            3,
            user_id=user.id,
            title="Other title",
            description="other description",
            state=TodoState.todo,
        )
    )
    await session.commit()

    response = client.get(
        "/todos/?title=Test todo combined&description=combined&state=done",
        headers={"Authorization": f"Bearer {token}"},
    )

    assert len(response.json()["todos"]) == expected_todos


@pytest.mark.asyncio
async def test_patch_todo(session, client, user, token) -> None:
    todo = TodoFactory(user_id=user.id)

    session.add(todo)
    await session.commit()

    response = client.patch(
        f"/todos/{todo.id}",
        json={"title": "teste!"},
        headers={"Authorization": f"Bearer {token}"},
    )
    assert response.status_code == HTTPStatus.OK
    assert response.json()["title"] == "teste!"


def test_patch_todo_error(client, token) -> None:
    response = client.patch(
        "/todos/10",
        json={},
        headers={"Authorization": f"Bearer {token}"},
    )
    assert response.status_code == HTTPStatus.NOT_FOUND
    assert response.json() == {"detail": "Task not found."}


@pytest.mark.asyncio
async def test_delete_todo(session, client, user, token) -> None:
    todo = TodoFactory(user_id=user.id)

    session.add(todo)
    await session.commit()

    response = client.delete(
        f"/todos/{todo.id}", headers={"Authorization": f"Bearer {token}"}
    )

    assert response.status_code == HTTPStatus.OK
    assert response.json() == {"message": "Task has been deleted successfully."}


def test_delete_todo_error(client, token) -> None:
    response = client.delete(
        f"/todos/{10}", headers={"Authorization": f"Bearer {token}"}
    )

    assert response.status_code == HTTPStatus.NOT_FOUND
    assert response.json() == {"detail": "Task not found."}
